#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <malloc.h>

struct size //структура для хранения данных о массиве
{
    int x;
    int y;
    int type;//размер данных
};
struct complex
{
    int re;
    int im;
};
int viborchisel()
{
    int vch;
    printf("Введите 1, если матрица состоит из целых чисел, 2, если из вещественных, 3, если из комплексных. Ввод:");
    scanf("%d",&vch);
    return(vch);
}
int viboroper()
{
    int vop;
    printf("Введите 1, если требуется вычислить сумму матриц, введите 2, если требуется вычислить произведение матриц,3 если требуется запустить тест. Ввод:");
    scanf("%d",&vop);
    return(vop);
}
void entersizematrix(struct size *s,int i)
{
    printf("Введите размеры матрицы %d. Количество строк:",i);
    scanf("%d",&s->x);
    printf("Введите размеры первой матрицы %d. Количество столбцов:",i);
    scanf("%d",&s->y);
}
int checkcorrectness(int vop,struct size f,struct size s) //проверка корректности ввода данных
{
    int flag;
    if (vop==1)
    {
      if( (f.x!=s.x)||(f.y!=s.y) )
      {
          printf("Данные матрицы не могут быть сложены из-за несоответствия размеров. Размеры матриц должны быть одинаковыми");
          flag=2;
      }
      if( (f.x==s.x)&&(f.y==s.y) )
      {
       flag=1;
      }
    }
    if (vop==2)
    {
        if ( (f.y!=s.x) )
        {
            printf("Данные матрицы не могут быть умножены из-за несоответствия размеров. Количество столбцов первой матрицы должны быть равно количеству строк второй");
            flag=2;
        }
        if (f.y==s.x)
            {
            flag=1;
            }
    }
    return(flag);
}

void* fillmatrix(struct size f, int vch,int p) //заполнение матрицы
{
    int i,j;
    void* a=malloc(f.x*f.y*f.type);
    printf("Элементы матрицы %d",p);
    printf("\n");
    for (i=0;i<f.x*f.y;i++)
    {
                if (vch==1)
                {
                    scanf("%d",(int*)a+i);
                }
                if (vch==2)
                {
                    scanf("%f",(float*)a+i);
                }
                if (vch==3)
                {
                    printf("re=");
                    scanf(" %d", ((int*)a + 2*i ));
                    printf("im=");
                    scanf(" %d", ((int*)a + 2*i+1));
                }
    }
   return a;
}

void printmatrix (struct size f,void* a,int vch) //вывод матрицы
{
   int i,j;
    for(i=0;i<f.x*f.y;i++)
    {
            if (vch==1)
            {
               printf(" %d ",*((int*)a + i));
            }
            if (vch==2)
            {
                printf(" %.2f ",*((float*)a + i));
            }
            if (vch==3)
            {
               printf(" %d + %di",*((int*)a + 2*i ),*((int*)a + 2*i + 1));
            }
        printf("\n");
    }

}



void sumint(void* a, void* b)
{
    *((int*)a)+=*((int*)b);
}
void sumfloat(void* a, void* b)
{
    *((float*)a) += *((float*)b);
}
void sumcomplex(void* a, void* b) {
    *((int*)a) += *((int*)b);
    *((int*)a+1) += *((int*)b+1);
}

void summatrix(int vch,struct size f,void* a, void* b, void (*func)(void* a, void* b))
{
    int i,j;
    for (i=0;i<f.x*f.y;i++)
     {
      func(a+i*f.type, b+i*f.type);
     }
     printf("Результатом будет матрица:\n");
     printmatrix(f,a,vch);
}

void multint(void* a, void* b, void* c)
{
    *((int*)c) += *((int*)a) * *((int*)b);
}


void multfloat(void* a, void* b,void* c)
{
    *((float*)c) += *((float*)a) * *((float*)b);
}

void multcomplex(void* a, void* b, void* c)
{
    *((int*)c) += *((int*)a) * *((int*)b) - *((int*)a+1) * *((int*)b+1);
    *((int*)c+1) += *((int*)a) * *((int*)b+1) + *((int*)a+1) * *((int*)b);
}

void* multmatrix(struct size first,struct size second,void* a, void* b, void (*func)(void* a, void* b, void* c))
{
    void *c = calloc(first.x*second.y,first.type);
    int i,j,k;
    for (i = 0; i < first.x; i++) {
        for (j=0; j<second.y; j++) {
            for (k = 0; k < first.y; k++) {
                func(a+(i*first.x+k)*first.type, b+(k*second.y+j)*first.type, c+(i*first.y+j)*first.type);
            }
        }
    }
    return c;
}

test (int vch)
{
    int i,j;
    struct size f,s,t;
    f.x=2;
    f.y=2;
    s.x=2;
    s.y=2;
    t.x=2;
    t.y=2;
    if (vch==1)
    {
        f.type=sizeof(int);//присвоить третьеу элементы структуры нужное значение
    }
    if (vch==2)
    {
        f.type=sizeof(float);
    }
    if (vch==3)
    {
        f.type=sizeof(struct complex);
    }
    void *a=calloc(f.x*f.y,f.type);
    void *b=calloc(f.x*f.y,f.type);
    void *c;
    if (vch==1)
    {
        for (i=0;i<f.x*f.y;i++)
        {
             *((int*)b+i) = 8+i;
        }
        *((int*)a)=5;
        *((int*)a+1)=3;
        *((int*)a+2)=8;
        *((int*)a+3)=2;
        c=multmatrix(f,s,a,b,multint);
       // printmatrix(t,c,vch);
        summatrix(vch,f,a,b,sumint);
        if (*((int*)c) != 70) printf("Ошибка при умножении\n");
        if (*((int*)c+1) != 78) printf("Ошибка при умножении\n");
        if (*((int*)c+2) != 84) printf("Ошибка при умножении\n");
        if (*((int*)c+3) != 94) printf("Ошибка при умножении\n");
        if (*((int*)a) != 13) printf("Ошибка при сложении\n");
        if (*((int*)a+1) != 12) printf("Ошибка при сложении\n");
        if (*((int*)a+2) != 18) printf("Ошибка при сложении\n");
        if (*((int*)a+3) != 13) printf("Ошибка при сложении\n");
    }
    if (vch==2)
    {
        for (i=0;i<f.x*f.y;i++)
        {
             *((float*)b+i) = 8+i;
        }
        *((float*)a)=5;
        *((float*)a+1)=3;
        *((float*)a+2)=8;
        *((float*)a+3)=2;
        c=multmatrix(f,s,a,b,multfloat);
        summatrix(vch,f,a,b,sumfloat);
        if (*((float*)c) != 70) printf("Ошибка при умножении\n");
        if (*((float*)c+1) != 78) printf("Ошибка при умножении\n");
        if (*((float*)c+2) != 84) printf("Ошибка при умножении\n");
        if (*((float*)c+3) != 94) printf("Ошибка при умножении\n");
        if (*((float*)a) != 13) printf("Ошибка при сложении\n");
        if (*((float*)a+1) != 12) printf("Ошибка при сложении\n");
        if (*((float*)a+2) != 18) printf("Ошибка при сложении\n");
        if (*((float*)a+3) != 13) printf("Ошибка при сложении\n");

    }
    if (vch==3)
    {
        for (i=0;i<f.x*f.y;i++)
        {
             *((int*)b+2*i) = 8+i;
             *((int*)b+2*i+1) = 5;
        }
        *((int*)a)=5;
        *((int*)a+1)=3;
        *((int*)a+2)=8;
        *((int*)a+3)=2;
        *((int*)a+4)=3;
        *((int*)a+5)=0;
        *((int*)a+6)=9;
        *((int*)a+7)=1;
        c=multmatrix(f,s,a,b,multcomplex);
       // printmatrix(t,c,vch);
        summatrix(vch,f,a,b,sumcomplex);
        if (*((int*)c) != 95) printf("Ошибка при умножении\n");
        if (*((int*)c+1) != 109) printf("Ошибка при умножении\n");
        if (*((int*)c+2) != 108) printf("Ошибка при умножении\n");
        if (*((int*)c+3) != 114) printf("Ошибка при умножении\n");
        if (*((int*)c+4) != 109) printf("Ошибка при умножении\n");
        if (*((int*)c+5) != 70) printf("Ошибка при умножении\n");
        if (*((int*)c+6) != 121) printf("Ошибка при умножении\n");
        if (*((int*)c+7) != 71) printf("Ошибка при умножении\n");
        if (*((int*)a) != 13) printf("Ошибка при сложении\n");
        if (*((int*)a+1) != 8) printf("Ошибка при сложении\n");
        if (*((int*)a+2) != 17) printf("Ошибка при сложении\n");
        if (*((int*)a+3) != 7) printf("Ошибка при сложении\n");
        if (*((int*)a+4) != 13) printf("Ошибка при сложении\n");
        if (*((int*)a+5) != 5) printf("Ошибка при сложении\n");
        if (*((int*)a+6) != 20) printf("Ошибка при сложении\n");
        if (*((int*)a+7) != 6) printf("Ошибка при сложении\n");
    }
}

int main()
{
    int vch,vop,i,flag,j;//переменная, отвечающая за тип используемых чисел,переменная, отвечающая за тип операции
    void *a,*b,*c;
    struct size first,second,third;

    setlocale(LC_ALL, "Rus");
    vch=viborchisel();//ввести тип используемых чисел
    vop=viboroper();//ввести тип выполняемой опреации
    if (vch==1)
    {
        first.type=sizeof(int);//присвоить третьеу элементы структуры нужное значение
        second.type=sizeof(int);
    }
    if (vch==2)
    {
        first.type=sizeof(float);
        second.type=sizeof(float);
    }
    if (vch==3)
    {
        first.type=sizeof(struct complex);
        second.type=sizeof(struct complex);
    }
    if (vop==3)
    {
      test(vch);
    }
    if (vop!=3) {
    entersizematrix(&first,1);//ввести размеры первой матрицы
    entersizematrix(&second,2);//ввести размеры второй матрицы
    if (vop==1)//если выбрано сложение, то
    {
        flag=checkcorrectness(vop,first,second);//проверить, могут ли матрицы быть сложены
        if (flag==1)   // если могут , то
        {
         a=fillmatrix(first,vch,1);  //заполнить матрицы
         printmatrix(first,a,vch);
         b=fillmatrix(second,vch,2);
         printmatrix(second,b,vch);
         if (vch==1)summatrix(vch,first,a,b,sumint);//сложить матрицы
         if (vch==2)summatrix(vch,first,a,b,sumfloat);
         if (vch==3)summatrix(vch,first,a,b,sumcomplex);
        }
    }
    if (vop==2)//если выбрано умножение, то
    {
        flag=checkcorrectness(vop,first,second);//проверить корректность
        if (flag==1)//если корректно, то
        {
         a=fillmatrix(first,vch,1);  //заполнить матрицы
         printmatrix(first,a,vch);
         b=fillmatrix(second,vch,2);
         printmatrix(second,b,vch);
         third.x=first.x;
         third.y=second.y;
         if (vch==1)
         {
             c=multmatrix(first,second,a,b,multint);
             printf("Результатом будет матрица:\n");
             printmatrix(third,c,vch);
         }
        if (vch==2)
         {
             c=multmatrix(first,second,a,b,multfloat);
             printf("Результатом будет матрица:\n");
             printmatrix(third,c,vch);
         }
         if (vch==3)
         {
             c=multmatrix(first,second,a,b,multcomplex);
             printf("Результатом будет матрица:\n");
             printmatrix(third,c,vch);
         }
        }
    }
    }

    return 0;
}


